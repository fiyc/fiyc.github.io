<html>
<meta charset="utf-8" />
<title>Spring学习笔记</title>
<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" rel="stylesheet">
<link rel="stylesheet" href="../resource/common.css" type="text/css" />
<link rel="stylesheet" href="../resource/article.css" type="text/css" />
<link rel="stylesheet" href="../resource/article_media.css" media="screen and (max-width: 1024px)">

<body>
    <div class="main-container">
        <h1 id="spring-">Spring学习笔记</h1>
<h2 id="-bean">装配Bean</h2>
<h3 id="1-p34">1. 三种装配机制 <em>P34</em></h3>
<ul>
<li>在XML中进行显式配置</li>
<li>在Java中进行显式配置</li>
<li>隐式的bean发现机制和自动配置</li>
</ul>
<h3 id="2-p35">2. 自动化装配 <em>P35</em></h3>
<ul>
<li>@Component 表明该类会作为组件类, 并告知了Spring要为这个类创建bean.</li>
<li>@ComponentScan 启用扫描, 默认扫描与配置类相同的包</li>
</ul>
<h3 id="3-bean-p38">3. 为bean命名 <em>P38</em></h3>
<ul>
<li>默认类名首字母小写</li>
<li>传值给@Component - <code>@Component(&quot;name&quot;)</code></li>
<li>使用@Name注解, 可替代@Component</li>
</ul>
<h3 id="4-p39">4. 设置组件扫描的包 <em>P39</em></h3>
<ul>
<li>指定包名 - <code>@ComponentScan(&quot;packageName&quot;)</code></li>
<li>多个包名 - <code>@ComponentScan(basePackages={&quot;sundsystem&quot;, &quot;video&quot;})</code></li>
<li>使用类 - <code>@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})</code></li>
</ul>
<h3 id="5-bean-p40">5. bean自动装配 <em>P40</em></h3>
<ul>
<li>没有匹配的bean时出现异常</li>
<li>设置@Autowired的<code>required</code>属性避免异常</li>
</ul>
<h3 id="6-java-p44">6. 在Java中进行显式配置 <em>P44</em></h3>
<ul>
<li>@Configuration 表明这个类式一个配置类, 该类应该包含在spring上下文中如何创建bean的细节.</li>
</ul>
<h2 id="-">高级装配</h2>
<h3 id="7-profile-bean-p69">7. 使用profile控制bean的创建 <em>P69</em></h3>
<ul>
<li>@profile注解 <code>@profile(&#39;dev&#39;)</code>表明只有在dev profile激活时, 被标注的bean才会创建</li>
<li><code>spring.profiles.default</code> 与 <code>spring.profiles.active</code> 确定哪个profile激活</li>
</ul>
<h3 id="8-bean-p75">8. 条件化的bean <em>P75</em></h3>
<ul>
<li><code>@Conditional(class)</code></li>
<li>设置给@Conditional的类可以是任意实现了<code>org.springframework.context.annotation.Condition</code>接口的类</li>
</ul>
<h3 id="9-p78">9. 处理自动装配的歧义性 <em>P78</em></h3>
<ul>
<li>@Primary 标明首选项</li>
<li>@Qualifier 与@Autowired协同使用
<code>`</code>
@Autowired
@Qualifier(&quot;iceCream&quot;)
public void setDessert(Dessert dessert){
  this.dessert = dessert;
}</li>
</ul>
<p>@Component
public class IceCream implements Dessert(){
    ...
}</p>
<pre><code>* 创建自定义的限定符, 两边同时使用<span class="hljs-variable">@Qualifier</span>
* 使用自定义的限定符注解, 注解中使用了<span class="hljs-variable">@Qualifier</span></code></pre><p>@Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})
@REtention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Cold{}</p>
<pre><code>
<span class="hljs-section">### 10. bean的作用域 *P84*</span>
<span class="hljs-bullet">* </span>@Scope注解设置作用域
<span class="hljs-bullet">* </span>单例 - singleton
<span class="hljs-bullet">* </span>原型 - prototype
<span class="hljs-bullet">* </span>会话 - session
<span class="hljs-bullet">* </span>请求 - request
<span class="hljs-bullet">* </span>@Scope的proxyMode属性

<span class="hljs-section">### 11.运行时注入 *P88*</span>

<span class="hljs-section">## 面向切面</span>
<span class="hljs-section">### 12. AOP术语 *P103*</span>
<span class="hljs-bullet">* </span>通知(Advice)
<span class="hljs-bullet">* </span>连接点(Join point)
<span class="hljs-bullet">* </span>切点(Poincut)
<span class="hljs-bullet">* </span>切面(Aspect)
<span class="hljs-bullet">* </span>引入(Introduction)
<span class="hljs-bullet">* </span>织入(Weaving)

<span class="hljs-section">### 13. 切点表达式 *P109*</span>
<span class="hljs-code">`execution(* concert.Performance.perform(..)) &amp;&amp; withing(concert.*)`</span>


<span class="hljs-section">### 14. 定义切面 *P110*</span>
<span class="hljs-bullet">* </span>@Aspect 声明这是一个切面
<span class="hljs-bullet">* </span>@After 目标方法返回或抛出异常时通知
<span class="hljs-bullet">* </span>@AfterReturning 目标方法返回时通知
<span class="hljs-bullet">* </span>@AfterThrowing 目标方法抛出异常时通知
<span class="hljs-bullet">* </span>@Around 通知方法将目标方法封装
<span class="hljs-bullet">* </span>@Before 目标方法调用之前执行

<span class="hljs-section">### 15. 启动自动代理 *P113*</span>
<span class="hljs-bullet">* </span>@EnableAspectJAutoProxy</code></pre><p>@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class ConcertConfig{</p>
<pre><code><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="hljs-function">Audience <span class="hljs-title">audience</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Audience();
}</code></pre><p>}</p>
<pre><code>
### <span class="hljs-number">16.</span> 环绕通知 *P114*</code></pre><p>@Around(&quot;performance()&quot;)
public void watchPerformance(ProceedingJoinPoint jp){
    ...
    jp.proceed();
    ...
}
<code>`</code></p>
<h2 id="web-spring">Web中的Spring</h2>
<h3 id="17-spring-mvc-p136">17. 跟踪Spring MVC的请求 <em>P136</em></h3>
<h3 id="18-spring-mvc-p138">18. 搭建Spring MVC <em>P138</em></h3>
<h3 id="19-srping-mvc-p140">19. 启动Srping MVC <em>P140</em></h3>
<ul>
<li>@EnableWebMvc</li>
</ul>
<h3 id="20-">20. 编写控制器</h3>
<ul>
<li>@Controller 声明为一个控制器</li>
<li>@RequestMapping 指定请求路径</li>
</ul>

    </div>
</body>
</html>