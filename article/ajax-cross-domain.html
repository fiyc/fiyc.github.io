<html>
<meta charset="utf-8" />
<title>跨域问题解析</title>
<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" rel="stylesheet">
<link rel="stylesheet" href="../resource/common.css" type="text/css" />
<link rel="stylesheet" href="../resource/article.css" type="text/css" />
<link rel="stylesheet" href="../resource/article_media.css" media="screen and (max-width: 1024px)">

<body>
    <div class="main-container">
        <h1 id="-">跨域问题解析</h1>
<p>之前在项目中遇到跨域问题, 只是简单的搜索了下解决方案. 使用<code>jsonp</code>解决问题后并没有做深入的了解. 这次在<a href="https://www.imooc.com/video/16571">慕课网</a>看到了关于跨域的课程, 觉得听完还是学到了一些东西, 因此这里专门做了一次记录.  </p>
<!-- more -->

<h2 id="-">跨域产生的原因</h2>
<p>跨域问题简单的说, 就是发起一次<code>XHR(XMLHttpRequest)</code>请求时, 如果调用发与被调用方所在<code>域</code>不同, <code>浏览器</code>就认为这是一个跨域请求, 并对本次请求做出限制. 也就是说, 产生跨域问题必须要满足下面三个条件:  </p>
<ul>
<li>XHR请求</li>
<li>调用方与被调用方不同域</li>
<li>浏览器会对跨域做限制</li>
</ul>
<p>同时我们也可以认清一点, 跨域问题是发送在浏览器端做的限制. </p>
<h2 id="-">解决方案</h2>
<p>基于上面提到的跨域的三个条件, 我们的解决思路就可以从这三点入手. 只要使得这3个条件中的任意一个条件不满足, 跨域问题自然就可以得到解决.</p>
<h3 id="-">浏览器</h3>
<p>从浏览器端入手解决跨域问题, 也就是告诉浏览器, 不需要你去做跨域的处理啦. 这里我的环境是MaxOS下使用Chrome, 其他的系统或者浏览器的解决方案并没有做了解. 因为通过浏览器解除限制来解决跨域问题并不是一个合适的手段, 可能只会在调试时使用到.  </p>
<ol>
<li><p>首先进入Chrome所在目录</p>
<pre><code><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /Applications/Google Chrome.app/Contents/MacOS/</span></code></pre></li>
<li><p>备份原有的启动文件</p>
<pre><code><span class="hljs-meta">$</span><span class="bash"> sudo mv <span class="hljs-string">"Google Chrome"</span> startbackup</span></code></pre></li>
<li><p>创建新的启动文件, 在其中加入参数</p>
<pre><code>$ $ sudo <span class="hljs-built_in">printf</span> <span class="hljs-string">'#!/bin/bash\ncd "</span>/Applications/Google Chrome.app/Contents/MacOS<span class="hljs-string">"\n"</span>/Applications/Google Chrome.app/Contents/MacOS/startbackup<span class="hljs-string">" --disable-web-security --user-data-dir "</span>$@<span class="hljs-string">"\n'</span> &gt; Google\ Chrome</code></pre></li>
<li><p>为新的启动文件添加执行权限</p>
<pre><code><span class="hljs-meta">$</span><span class="bash"> sudo chmod u+x <span class="hljs-string">"Google Chrome"</span></span></code></pre></li>
</ol>
<p>这种方式的局限性很大, 因为它必须要在客户端进行修改. 在实际生产环境中, 让每个用户去修改自己的浏览器是不现实的. 因此这种方式只适用于开发者本身调试时使用.</p>
<h3 id="jsonp">jsonp</h3>
<p>通过jsonp这种方式来解决跨域问题是我之前使用的一种方式, 他的思路就是针对上面三个条件的<code>XHR请求</code>这一点. 通过设置ajax请求类型为jsonp, 我们将请求的类型由<code>XHR</code>变为了<code>script</code>, 自然也就没有了跨域的问题.  </p>
<p>实现jsonp的原理是, 调用方与被调用方通过约定一个js函数名(默认通过callback参数传递), 被调用方返回的信息由原本的json对象变为了执行这个函数的js脚本, 入参就是原本的json对象. 调用方在请求完成之后, 在页面中添加这一段返回的脚本, 执行获取到结果后再删除这一段脚本.  </p>
<p>我们通常的实现代码如下:</p>
<pre><code><span class="hljs-comment">//客户端</span>
$.ajax({
    url: xxx,
    <span class="hljs-keyword">type</span>: jsonp,
    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        ...
    }
});

<span class="hljs-comment">//服务器端 c#</span>
<span class="hljs-keyword">var</span> result = GetResult();
<span class="hljs-keyword">var</span> callback = context.HttpContext.Request[<span class="hljs-string">"callback"</span>];
<span class="hljs-keyword">var</span> buffer = <span class="hljs-built_in">string</span>.Empty;

<span class="hljs-keyword">var</span> serializer = <span class="hljs-keyword">new</span> JavaScriptSerializer();
<span class="hljs-keyword">if</span>(callback != <span class="hljs-literal">null</span>)
{
    buffer = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">"{0}({1})"</span>, callback, serializer.Serialize(result));
}
<span class="hljs-keyword">else</span>
{
    buffer = serializer.Serialize(result);
}

context.Httpcontext.Response.Write(buffer);</code></pre><p>在上面的代码中, <code>jQury</code>已经为我们封装了一些针对jsonp的操作, 包括创建script标签并将标签引用地址设置为我们的请求地址, 赋值等操作. 如果有兴趣的可以去看一下源码.  </p>
<p>当然, jsonp存在着他自身的缺陷, 主要有下面几点:  </p>
<ul>
<li>需要服务器端同时支持jsonp  </li>
</ul>
<p>在上面的代码例子里可以看到, 当请求为jsonp时, 服务器端需要修改返回数据体的格式为一段js脚本. 但是在实际情况下, 一些我们请求的地址并不一定受我们控制, 它可能并不支持jsonp. 这种情况下, jsonp就不适用了.  </p>
<ul>
<li>由于jsonp的实质是动态添加script标签, 因此它只支持<code>GET</code>请求.</li>
<li>并不能使用<code>XHR</code>的一些特性</li>
</ul>
<h3 id="-">被调用方修改返回头</h3>
<p>我们可以在被调用方的返回头信息中, 标注说明支持跨域, 具体的头信息如下:</p>
<pre><code>{
    Access-Control-Allow-Origin: <span class="hljs-string">"*"</span>,
    Access-Control-Allow-Methods: <span class="hljs-string">"<span class="hljs-keyword">GET</span>"</span>
}
</code></pre><p>这样, 就可以支持<code>简单请求</code>的跨域问题.</p>
<h4 id="-">简单请求与非简单请求</h4>
<p>上面提到了一个概念叫做<code>简单请求</code>, 那么与之对应的就存在<code>非简单请求</code>.  </p>
<p>简单请求需要满足以下两个条件:</p>
<ul>
<li>请求方式为: HEAD, GET, POST</li>
<li>请求头中<code>Content-Type</code>需要是: <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code>之一</li>
</ul>
<p>不满足上述两点的请求, 则为非简单请求.  </p>
<p>简单请求与非简单请求的差别在于, 非简单请求在发送我们希望的请求前, 会先发送一个<code>OPTIONS</code>请求, 向服务器进行验证. 只有验证通过以后才会继续请求.</p>
<h4 id="-cookie-">带cookie的跨域请求</h4>
<p>上面我们提到被调用方通过在返回头信息中添加<code>Access-Control-Allow-Origi: *</code>来支持跨域请求, 但是如果跨域请求需要带上<code>cookie</code>信息, 那么此时服务器端的返回头信息就需要进行修改.  </p>
<ol>
<li>首先<code>Access-Control-Allow-Origi</code>不能使用<code>*</code>来匹配所有的请求, 而需要指定被调用方的域名.  </li>
<li>返回头中, <code>Access-Control-Allow-Credentials</code>需要设置为true.  </li>
</ol>
<p>针对上面第一点, 我们可能会发现一个问题, 那就是如果写死调用方域名的话, 被调用方岂不是只支持一个指定调用方的跨域请求了. 为了解决这个问题, 我们可以从请求头中的<code>Origin</code>获取到调用方的域名, 然后将这个值作为<code>Access-Control-Allow-Origin</code>.</p>
<h3 id="-nginx-">被调用方Nginx配置</h3>
<p>这里是通过修改被调用方的服务器配置来实现添加返回头信息  </p>
<ol>
<li><p>Nginx配置引入自定义配置  </p>
<pre><code class="language-shell"><span class="hljs-attribute">include</span> vhost/<span class="hljs-regexp">*.conf</span></code></pre>
</li>
<li><p>添加配置文件 <code>vhost/fiyc.space.conf</code>  </p>
<pre><code>server{
 listen <span class="hljs-number">80</span>;
 server_name fiyc.spance;

 location /{
     proxy_pass <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhsot:8080/</span>;

     add_header Access-Control-Allow-Methods *;
     add_header Access-Control-Max-Age <span class="hljs-number">3600</span>;
     add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;

     <span class="hljs-comment">#获取请求头中的origin</span>
     add_header Access-Control-Allow-Origin $http_origin;

     <span class="hljs-comment">#获取请求头中的自定义headers</span>
     add_header Access-Control-Request-Headers $http_access_control_request_headers;

     <span class="hljs-comment">#处理预检命令</span>
     <span class="hljs-keyword">if</span> ($request_method = OPTIONS){
         <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;
     }
 }
}</code></pre></li>
</ol>
<h3 id="-">调用方隐藏跨域</h3>
<p>这里的思路是修改调用方服务器, 将一个本地请求路径转发到目标服务器地址, 下面是Nginx的配置内容</p>
<pre><code>server{
    listen <span class="hljs-number">80</span>;
    server_name fiyc.space

    <span class="hljs-keyword">location</span> <span class="hljs-title">/{
        proxy_pass</span> http://locahost:<span class="hljs-number">8081</span>/;
    }

    <span class="hljs-keyword">location</span> <span class="hljs-title">/ajaxserver</span>{
        proxy_pass http://localhost:<span class="hljs-number">8080</span>/test/
    }
}</code></pre>
    </div>
</body>
</html>